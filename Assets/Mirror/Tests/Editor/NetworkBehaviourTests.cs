using Mirror.RemoteCalls;
using NUnit.Framework;
using UnityEngine;
using UnityEngine.TestTools;

namespace Mirror.Tests
{
    class EmptyBehaviour : NetworkBehaviour {}

    class SyncVarGameObjectEqualExposedBehaviour : NetworkBehaviour
    {
        public bool SyncVarGameObjectEqualExposed(GameObject newGameObject, uint netIdField)
        {
            return SyncVarGameObjectEqual(newGameObject, netIdField);
        }
    }

    class SyncVarNetworkIdentityEqualExposedBehaviour : NetworkBehaviour
    {
        public bool SyncVarNetworkIdentityEqualExposed(NetworkIdentity newNetworkIdentity, uint netIdField)
        {
            return SyncVarNetworkIdentityEqual(newNetworkIdentity, netIdField);
        }
    }

    // we need to inherit from networkbehaviour to test protected functions
    public class NetworkBehaviourSendCommandInternalComponent : NetworkBehaviour
    {
        // counter to make sure that it's called exactly once
        public int called;

        // weaver generates this from [Command]
        // but for tests we need to add it manually
        public static void CommandGenerated(NetworkBehaviour comp, NetworkReader reader, NetworkConnection senderConnection)
        {
            ++((NetworkBehaviourSendCommandInternalComponent)comp).called;
        }

        // SendCommandInternal is protected. let's expose it so we can test it.
        public void CallSendCommandInternal(bool requiresAuthority = true)
        {
            SendCommandInternal(GetType(), nameof(CommandGenerated), new NetworkWriter(), 0, requiresAuthority);
        }
    }

    // we need to inherit from networkbehaviour to test protected functions
    public class NetworkBehaviourSendRPCInternalComponent : NetworkBehaviour
    {
        // counter to make sure that it's called exactly once
        public int called;

        // weaver generates this from [ClientRpc]
        // but for tests we need to add it manually
        public static void RPCGenerated(NetworkBehaviour comp, NetworkReader reader, NetworkConnection senderConnection)
        {
            ++((NetworkBehaviourSendRPCInternalComponent)comp).called;
        }

        // SendCommandInternal is protected. let's expose it so we can test it.
        public void CallSendRPCInternal()
        {
            SendRPCInternal(GetType(), nameof(RPCGenerated), new NetworkWriter(), 0, false);
        }
    }

    // we need to inherit from networkbehaviour to test protected functions
    public class NetworkBehaviourSendTargetRPCInternalComponent : NetworkBehaviour
    {
        // counter to make sure that it's called exactly once
        public int called;

        // weaver generates this from [TargetRpc]
        // but for tests we need to add it manually
        public static void TargetRPCGenerated(NetworkBehaviour comp, NetworkReader reader, NetworkConnection senderConnection)
        {
            ++((NetworkBehaviourSendTargetRPCInternalComponent)comp).called;
        }

        // SendCommandInternal is protected. let's expose it so we can test it.
        public void CallSendTargetRPCInternal(NetworkConnection conn)
        {
            SendTargetRPCInternal(conn, GetType(), nameof(TargetRPCGenerated), new NetworkWriter(), 0);
        }
    }

    // we need to inherit from networkbehaviour to test protected functions
    public class NetworkBehaviourDelegateComponent : NetworkBehaviour
    {
        public static void Delegate(NetworkBehaviour comp, NetworkReader reader, NetworkConnection senderConnection) {}
        public static void Delegate2(NetworkBehaviour comp, NetworkReader reader, NetworkConnection senderConnection) {}
    }

    // we need to inherit from networkbehaviour to test protected functions
    public class NetworkBehaviourSetSyncVarGameObjectComponent : NetworkBehaviour
    {
        //[SyncVar]
        public GameObject test;
        // usually generated by weaver
        public uint testNetId;

        // SetSyncVarGameObject wrapper to expose it
        public void SetSyncVarGameObjectExposed(GameObject newGameObject, ulong dirtyBit)
        {
            SetSyncVarGameObject(newGameObject, ref test, dirtyBit, ref testNetId);
        }
    }

    // we need to inherit from networkbehaviour to test protected functions
    public class NetworkBehaviourGetSyncVarGameObjectComponent : NetworkBehaviour
    {
        //[SyncVar]
        public GameObject test;
        // usually generated by weaver
        public uint testNetId;

        // SetSyncVarGameObject wrapper to expose it
        public GameObject GetSyncVarGameObjectExposed()
        {
            return GetSyncVarGameObject(testNetId, ref test);
        }
    }

    // we need to inherit from networkbehaviour to test protected functions
    public class NetworkBehaviourSetSyncVarNetworkIdentityComponent : NetworkBehaviour
    {
        //[SyncVar]
        public NetworkIdentity test;
        // usually generated by weaver
        public uint testNetId;

        // SetSyncVarNetworkIdentity wrapper to expose it
        public void SetSyncVarNetworkIdentityExposed(NetworkIdentity newNetworkIdentity, ulong dirtyBit)
        {
            SetSyncVarNetworkIdentity(newNetworkIdentity, ref test, dirtyBit, ref testNetId);
        }
    }

    // we need to inherit from networkbehaviour to test protected functions
    public class NetworkBehaviourGetSyncVarNetworkIdentityComponent : NetworkBehaviour
    {
        //[SyncVar]
        public NetworkIdentity test;
        // usually generated by weaver
        public uint testNetId;

        // SetSyncVarNetworkIdentity wrapper to expose it
        public NetworkIdentity GetSyncVarNetworkIdentityExposed()
        {
            return GetSyncVarNetworkIdentity(testNetId, ref test);
        }
    }

    // we need to inherit from networkbehaviour to test protected functions
    public class NetworkBehaviourInitSyncObjectExposed : NetworkBehaviour
    {
        public void InitSyncObjectExposed(SyncObject obj)
        {
            InitSyncObject(obj);
        }
    }

    // we need to inherit from networkbehaviour to test protected functions
    public class OnStopClientComponent : NetworkBehaviour
    {
        public int called;
        public override void OnStopClient()
        {
            ++called;
        }
    }

    // we need to inherit from networkbehaviour to test protected functions
    public class OnStartClientComponent : NetworkBehaviour
    {
        public int called;
        public override void OnStartClient()
        {
            ++called;
        }
    }

    // we need to inherit from networkbehaviour to test protected functions
    public class OnStartLocalPlayerComponent : NetworkBehaviour
    {
        public int called;
        public override void OnStartLocalPlayer()
        {
            ++called;
        }
    }

    public class NetworkBehaviourTests : MirrorEditModeTest
    {
        [TearDown]
        public override void TearDown()
        {
            NetworkServer.RemoveLocalConnection();
            base.TearDown();
        }

        [Test]
        public void IsServerOnly()
        {
            CreateNetworked(out GameObject gameObject, out NetworkIdentity identity, out EmptyBehaviour emptyBehaviour);

            // call OnStartServer so isServer is true
            identity.OnStartServer();
            Assert.That(identity.isServer, Is.True);

            // isServerOnly should be true when isServer = true && isClient = false
            Assert.That(emptyBehaviour.isServer, Is.True);
            Assert.That(emptyBehaviour.isClient, Is.False);
            Assert.That(emptyBehaviour.isServerOnly, Is.True);
        }

        [Test]
        public void IsClientOnly()
        {
            CreateNetworked(out GameObject gameObject, out NetworkIdentity identity, out EmptyBehaviour emptyBehaviour);

            // isClientOnly should be true when isServer = false && isClient = true
            identity.isClient = true;
            Assert.That(emptyBehaviour.isServer, Is.False);
            Assert.That(emptyBehaviour.isClient, Is.True);
            Assert.That(emptyBehaviour.isClientOnly, Is.True);
        }

        [Test]
        public void HasNoAuthorityByDefault()
        {
            // no authority by default
            CreateNetworked(out GameObject gameObject, out NetworkIdentity identity, out EmptyBehaviour emptyBehaviour);
            Assert.That(emptyBehaviour.hasAuthority, Is.False);
        }

        [Test]
        public void HasIdentitysNetId()
        {
            CreateNetworked(out GameObject gameObject, out NetworkIdentity identity, out EmptyBehaviour emptyBehaviour);
            identity.netId = 42;
            Assert.That(emptyBehaviour.netId, Is.EqualTo(42));
        }

        [Test]
        public void HasIdentitysConnectionToServer()
        {
            CreateNetworked(out GameObject gameObject, out NetworkIdentity identity, out EmptyBehaviour emptyBehaviour);
            identity.connectionToServer = new LocalConnectionToServer();
            Assert.That(emptyBehaviour.connectionToServer, Is.EqualTo(identity.connectionToServer));
        }

        [Test]
        public void HasIdentitysConnectionToClient()
        {
            CreateNetworked(out GameObject gameObject, out NetworkIdentity identity, out EmptyBehaviour emptyBehaviour);
            identity.connectionToClient = new LocalConnectionToClient();
            Assert.That(emptyBehaviour.connectionToClient, Is.EqualTo(identity.connectionToClient));
        }

        [Test]
        public void ComponentIndex()
        {
            // create a NetworkIdentity with two components
            CreateNetworked(out GameObject _, out NetworkIdentity _, out EmptyBehaviour first, out EmptyBehaviour second);
            Assert.That(first.ComponentIndex, Is.EqualTo(0));
            Assert.That(second.ComponentIndex, Is.EqualTo(1));
        }

        [Test, Ignore("NetworkServerTest.SendCommand does it already")]
        public void SendCommandInternal() {}

        // test to prevent https://github.com/vis2k/Mirror/issues/2629
        // from happening again in the future
        // -> [Command]s can be called on other objects with requiresAuthority=false.
        // -> those objects don't have a .connectionToServer
        // -> we broke it when using .connectionToServer instead of
        //    NetworkClient.connection in SendCommandInternal.
        [Test]
        public void SendCommandInternal_RequiresAuthorityFalse_ForOtherObjectWithoutConnectionToServer()
        {
            // we need to start a server and connect a client in order to be
            // able to send commands
            // message handlers
            NetworkServer.RegisterHandler<SpawnMessage>((conn, msg) => {}, false);
            NetworkServer.Listen(1);
            Assert.That(NetworkServer.active, Is.True);

            // create a connection from client to server and from server to client
            CreateLocalConnectionPair(out LocalConnectionToClient connectionToClient,
                                      out LocalConnectionToServer connectionToServer);
            connectionToClient.isReady = true;
            connectionToClient.isAuthenticated = true;
            connectionToServer.isReady = true;
            connectionToServer.isAuthenticated = true;

            // connect client
            NetworkClient.Connect("localhost");
            Assert.That(NetworkClient.active, Is.True);

            // add command component
            CreateNetworked(out GameObject _, out NetworkIdentity identity, out NetworkBehaviourSendCommandInternalComponent comp);

            // DO NOT ASSIGN connectionToServer for the identity

            // isClient needs to be true, otherwise we can't call commands
            identity.isClient = true;

            // register our connection at the server so that it sets up the
            // connection's handlers
            NetworkServer.AddConnection(connectionToClient);

            // register the command delegate, otherwise it's not found
            int registeredHash = RemoteCallHelper.RegisterDelegate(typeof(NetworkBehaviourSendCommandInternalComponent),
                    nameof(NetworkBehaviourSendCommandInternalComponent.CommandGenerated),
                    MirrorInvokeType.Command,
                    NetworkBehaviourSendCommandInternalComponent.CommandGenerated,
                    false);

            // identity needs to be in spawned dict, otherwise command handler
            // won't find it
            NetworkIdentity.spawned[identity.netId] = identity;

            // clientscene.readyconnection needs to be set for commands
            NetworkClient.connection = connectionToServer;
            NetworkClient.Ready();

            // call command. don't require authority.
            // the object doesn't have a .connectionToClient (like a scene object)
            comp.CallSendCommandInternal(false);
            Assert.That(comp.called, Is.EqualTo(1));

            // clean up
            RemoteCallHelper.RemoveDelegate(registeredHash);
        }

        [Test]
        public void SendRPCInternal()
        {
            CreateNetworked(out GameObject gameObject, out NetworkIdentity identity, out NetworkBehaviourSendRPCInternalComponent comp);

            // calling rpc before server is active shouldn't work
            LogAssert.Expect(LogType.Error, "RPC Function " + nameof(NetworkBehaviourSendRPCInternalComponent.RPCGenerated) + " called on Client.");
            comp.CallSendRPCInternal();
            Assert.That(comp.called, Is.EqualTo(0));

            // we need to start a server and connect a client in order to be
            // able to send commands
            // message handlers
            NetworkServer.RegisterHandler<SpawnMessage>((conn, msg) => {}, false);
            NetworkServer.Listen(1);
            Assert.That(NetworkServer.active, Is.True);

            // connect host client
            NetworkClient.ConnectHost();
            Assert.That(NetworkClient.active, Is.True);

            // get the host connection which already has client->server and
            // server->client set up
            LocalConnectionToServer connectionToServer = (LocalConnectionToServer)NetworkClient.connection;

            // set host connection as ready and authenticated
            connectionToServer.isReady = true;
            connectionToServer.isAuthenticated = true;
            connectionToServer.connectionToClient.isReady = true;
            connectionToServer.connectionToClient.isAuthenticated = true;
            connectionToServer.connectionToClient.identity = identity;

            // calling rpc before isServer is true shouldn't work
            LogAssert.Expect(LogType.Warning, "ClientRpc " + nameof(NetworkBehaviourSendRPCInternalComponent.RPCGenerated) + " called on un-spawned object: " + gameObject.name);
            comp.CallSendRPCInternal();
            Assert.That(comp.called, Is.EqualTo(0));

            // we need an observer because sendrpc sends to ready observers
            // creates observers
            identity.OnStartServer();
            identity.observers[connectionToServer.connectionToClient.connectionId] = connectionToServer.connectionToClient;

            // isServer needs to be true, otherwise we can't call rpcs
            Assert.That(comp.isServer, Is.True);

            // register the command delegate, otherwise it's not found
            int registeredHash = RemoteCallHelper.RegisterDelegate(typeof(NetworkBehaviourSendRPCInternalComponent),
                nameof(NetworkBehaviourSendRPCInternalComponent.RPCGenerated),
                MirrorInvokeType.ClientRpc,
                NetworkBehaviourSendRPCInternalComponent.RPCGenerated);

            // identity needs to be in spawned dict, otherwise rpc handler
            // won't find it
            NetworkIdentity.spawned[identity.netId] = identity;

            // call rpc
            comp.CallSendRPCInternal();

            // update client's connection so that pending messages are processed
            connectionToServer.Update();

            // rpc should have been called now
            Assert.That(comp.called, Is.EqualTo(1));

            // clean up
            RemoteCallHelper.RemoveDelegate(registeredHash);
            // clear clientscene.readyconnection
            NetworkServer.RemoveLocalConnection();
        }

        [Test]
        public void SendTargetRPCInternal()
        {
            CreateNetworked(out GameObject gameObject, out NetworkIdentity identity, out NetworkBehaviourSendTargetRPCInternalComponent comp);

            // calling rpc before server is active shouldn't work
            LogAssert.Expect(LogType.Error, $"TargetRPC {nameof(NetworkBehaviourSendTargetRPCInternalComponent.TargetRPCGenerated)} called when server not active");
            comp.CallSendTargetRPCInternal(null);
            Assert.That(comp.called, Is.EqualTo(0));

            // we need to start a server and connect a client in order to be
            // able to send commands
            // message handlers
            NetworkServer.RegisterHandler<SpawnMessage>((conn, msg) => {}, false);
            NetworkServer.Listen(1);
            Assert.That(NetworkServer.active, Is.True);

            // connect host client
            NetworkClient.ConnectHost();
            Assert.That(NetworkClient.active, Is.True);

            // get the host connection which already has client->server and
            // server->client set up
            LocalConnectionToServer connectionToServer = (LocalConnectionToServer)NetworkClient.connection;

            // set host connection as ready and authenticated
            connectionToServer.isReady = true;
            connectionToServer.isAuthenticated = true;
            connectionToServer.connectionToClient.isReady = true;
            connectionToServer.connectionToClient.isAuthenticated = true;
            connectionToServer.connectionToClient.identity = identity;

            // calling rpc before isServer is true shouldn't work
            LogAssert.Expect(LogType.Warning, $"TargetRpc {nameof(NetworkBehaviourSendTargetRPCInternalComponent.TargetRPCGenerated)} called on {gameObject.name} but that object has not been spawned or has been unspawned");
            comp.CallSendTargetRPCInternal(null);
            Assert.That(comp.called, Is.EqualTo(0));

            // call OnStartServer so isServer is true
            identity.OnStartServer();

            // calling rpc on connectionToServer shouldn't work
            LogAssert.Expect(LogType.Error, $"TargetRPC {nameof(NetworkBehaviourSendTargetRPCInternalComponent.TargetRPCGenerated)} requires a NetworkConnectionToClient but was given {typeof(NetworkConnectionToServer).Name}");
            comp.CallSendTargetRPCInternal(new NetworkConnectionToServer());
            Assert.That(comp.called, Is.EqualTo(0));

            // set proper connection to client
            identity.connectionToClient = connectionToServer.connectionToClient;

            // isServer needs to be true, otherwise we can't call rpcs
            Assert.That(comp.isServer, Is.True);

            // register the command delegate, otherwise it's not found
            int registeredHash = RemoteCallHelper.RegisterDelegate(typeof(NetworkBehaviourSendTargetRPCInternalComponent),
                nameof(NetworkBehaviourSendTargetRPCInternalComponent.TargetRPCGenerated),
                MirrorInvokeType.ClientRpc,
                NetworkBehaviourSendTargetRPCInternalComponent.TargetRPCGenerated);

            // identity needs to be in spawned dict, otherwise rpc handler
            // won't find it
            NetworkIdentity.spawned[identity.netId] = identity;

            // call rpc
            comp.CallSendTargetRPCInternal(null);

            // update client's connection so that pending messages are processed
            connectionToServer.Update();

            // rpc should have been called now
            Assert.That(comp.called, Is.EqualTo(1));

            // clean up
            RemoteCallHelper.RemoveDelegate(registeredHash);
            // clear clientscene.readyconnection
            NetworkServer.RemoveLocalConnection();
        }

        [Test]
        public void RegisterDelegateDoesntOverwrite()
        {
            // registerdelegate is protected, but we can use
            // RegisterCommandDelegate which calls RegisterDelegate
            int registeredHash1 = RemoteCallHelper.RegisterDelegate(
                typeof(NetworkBehaviourDelegateComponent),
                nameof(NetworkBehaviourDelegateComponent.Delegate),
                MirrorInvokeType.Command,
                NetworkBehaviourDelegateComponent.Delegate,
                false);

            // registering the exact same one should be fine. it should simply
            // do nothing.
            int registeredHash2 = RemoteCallHelper.RegisterDelegate(
                typeof(NetworkBehaviourDelegateComponent),
                nameof(NetworkBehaviourDelegateComponent.Delegate),
                MirrorInvokeType.Command,
                NetworkBehaviourDelegateComponent.Delegate,
                false);
            // registering the same name with a different callback shouldn't
            // work
            LogAssert.Expect(LogType.Error, "Function " + typeof(NetworkBehaviourDelegateComponent) + "." + nameof(NetworkBehaviourDelegateComponent.Delegate) + " and " + typeof(NetworkBehaviourDelegateComponent) + "." + nameof(NetworkBehaviourDelegateComponent.Delegate2) + " have the same hash.  Please rename one of them");
            int registeredHash3 = RemoteCallHelper.RegisterDelegate(
                typeof(NetworkBehaviourDelegateComponent),
                nameof(NetworkBehaviourDelegateComponent.Delegate),
                MirrorInvokeType.Command,
                NetworkBehaviourDelegateComponent.Delegate2,
                false);

            // clean up
            RemoteCallHelper.RemoveDelegate(registeredHash1);
            RemoteCallHelper.RemoveDelegate(registeredHash2);
            RemoteCallHelper.RemoveDelegate(registeredHash3);
        }

        [Test]
        public void GetDelegate()
        {
            // registerdelegate is protected, but we can use
            // RegisterCommandDelegate which calls RegisterDelegate
            int registeredHash = RemoteCallHelper.RegisterDelegate(
                typeof(NetworkBehaviourDelegateComponent),
                nameof(NetworkBehaviourDelegateComponent.Delegate),
                MirrorInvokeType.Command,
                NetworkBehaviourDelegateComponent.Delegate,
                false);

            // get handler
            int cmdHash = RemoteCallHelper.GetMethodHash(typeof(NetworkBehaviourDelegateComponent), nameof(NetworkBehaviourDelegateComponent.Delegate));
            CmdDelegate func = RemoteCallHelper.GetDelegate(cmdHash);
            CmdDelegate expected = NetworkBehaviourDelegateComponent.Delegate;
            Assert.That(func, Is.EqualTo(expected));

            // invalid hash should return null handler
            CmdDelegate funcNull = RemoteCallHelper.GetDelegate(1234);
            Assert.That(funcNull, Is.Null);

            // clean up
            RemoteCallHelper.RemoveDelegate(registeredHash);
        }

        // NOTE: SyncVarGameObjectEqual should be static later
        [Test]
        public void SyncVarGameObjectEqualZeroNetIdNullIsTrue()
        {
            CreateNetworked(out GameObject _, out NetworkIdentity identity, out SyncVarGameObjectEqualExposedBehaviour comp);
            // null and identity.netid==0 returns true (=equal)
            //
            // later we should reevaluate if this is so smart or not. might be
            // better to return false here.
            // => we possibly return false so that resync doesn't happen when
            //    GO disappears? or not?
            bool result = comp.SyncVarGameObjectEqualExposed(null, identity.netId);
            Assert.That(result, Is.True);
        }

        // NOTE: SyncVarGameObjectEqual should be static later
        [Test]
        public void SyncVarGameObjectEqualNull()
        {
            CreateNetworked(out GameObject _, out NetworkIdentity identity, out SyncVarGameObjectEqualExposedBehaviour comp);
            // our identity should have a netid for comparing
            identity.netId = 42;

            // null should return false
            bool result = comp.SyncVarGameObjectEqualExposed(null, identity.netId);
            Assert.That(result, Is.False);
        }

        // NOTE: SyncVarGameObjectEqual should be static later
        [Test]
        public void SyncVarGameObjectEqualZeroNetIdAndGOWithoutIdentityComponentIsTrue()
        {
            CreateNetworked(out GameObject _, out NetworkIdentity identity);
            CreateNetworked(out GameObject go, out NetworkIdentity _, out SyncVarGameObjectEqualExposedBehaviour comp);

            // null and identity.netid==0 returns true (=equal)
            //
            // later we should reevaluate if this is so smart or not. might be
            // better to return false here.
            // => we possibly return false so that resync doesn't happen when
            //    GO disappears? or not?
            bool result = comp.SyncVarGameObjectEqualExposed(go, identity.netId);
            Assert.That(result, Is.True);
        }

        // NOTE: SyncVarGameObjectEqual should be static later
        [Test]
        public void SyncVarGameObjectEqualWithoutIdentityComponent()
        {
            CreateNetworked(out GameObject _, out NetworkIdentity identity);

            // our identity should have a netid for comparing
            identity.netId = 42;

            // gameobject without networkidentity component should return false
            CreateNetworked(out GameObject go, out NetworkIdentity _, out SyncVarGameObjectEqualExposedBehaviour comp);
            bool result = comp.SyncVarGameObjectEqualExposed(go, identity.netId);
            Assert.That(result, Is.False);
        }

        // NOTE: SyncVarGameObjectEqual should be static later
        [Test]
        public void SyncVarGameObjectEqualValidGOWithDifferentNetId()
        {
            CreateNetworked(out GameObject _, out NetworkIdentity identity);

            // our identity should have a netid for comparing
            identity.netId = 42;

            // gameobject with valid networkidentity and netid that is different
            CreateNetworked(out GameObject go, out NetworkIdentity ni, out SyncVarGameObjectEqualExposedBehaviour comp);
            ni.netId = 43;
            bool result = comp.SyncVarGameObjectEqualExposed(go, identity.netId);
            Assert.That(result, Is.False);
        }

        // NOTE: SyncVarGameObjectEqual should be static later
        [Test]
        public void SyncVarGameObjectEqualValidGOWithSameNetId()
        {
            CreateNetworked(out GameObject _, out NetworkIdentity identity);

            // our identity should have a netid for comparing
            identity.netId = 42;

            // gameobject with valid networkidentity and netid that is different
            CreateNetworked(out GameObject go, out NetworkIdentity ni, out SyncVarGameObjectEqualExposedBehaviour comp);
            ni.netId = 42;
            bool result = comp.SyncVarGameObjectEqualExposed(go, identity.netId);
            Assert.That(result, Is.True);
        }

        // NOTE: SyncVarGameObjectEqual should be static later
        [Test]
        public void SyncVarGameObjectEqualUnspawnedGO()
        {
            CreateNetworked(out GameObject _, out NetworkIdentity identity);

            // our identity should have a netid for comparing
            identity.netId = 42;

            // gameobject with valid networkidentity and 0 netid that is unspawned
            CreateNetworked(out GameObject go, out NetworkIdentity ni, out SyncVarGameObjectEqualExposedBehaviour comp);
            LogAssert.Expect(LogType.Warning, "SetSyncVarGameObject GameObject " + go + " has a zero netId. Maybe it is not spawned yet?");
            bool result = comp.SyncVarGameObjectEqualExposed(go, identity.netId);
            Assert.That(result, Is.False);
        }

        // NOTE: SyncVarGameObjectEqual should be static later
        [Test]
        public void SyncVarGameObjectEqualUnspawnedGOZeroNetIdIsTrue()
        {
            CreateNetworked(out GameObject _, out NetworkIdentity identity);

            // unspawned go and identity.netid==0 returns true (=equal)
            CreateNetworked(out GameObject go, out NetworkIdentity ni, out SyncVarGameObjectEqualExposedBehaviour comp);
            LogAssert.Expect(LogType.Warning, "SetSyncVarGameObject GameObject " + go + " has a zero netId. Maybe it is not spawned yet?");
            bool result = comp.SyncVarGameObjectEqualExposed(go, identity.netId);
            Assert.That(result, Is.True);
        }

        // NOTE: SyncVarNetworkIdentityEqual should be static later
        [Test]
        public void SyncVarNetworkIdentityEqualZeroNetIdNullIsTrue()
        {
            CreateNetworked(out GameObject _, out NetworkIdentity identity, out SyncVarNetworkIdentityEqualExposedBehaviour comp);

            // null and identity.netid==0 returns true (=equal)
            //
            // later we should reevaluate if this is so smart or not. might be
            // better to return false here.
            // => we possibly return false so that resync doesn't happen when
            //    GO disappears? or not?
            bool result = comp.SyncVarNetworkIdentityEqualExposed(null, identity.netId);
            Assert.That(result, Is.True);
        }

        // NOTE: SyncVarNetworkIdentityEqual should be static later
        [Test]
        public void SyncVarNetworkIdentityEqualNull()
        {
            CreateNetworked(out GameObject _, out NetworkIdentity identity, out SyncVarNetworkIdentityEqualExposedBehaviour comp);

            // our identity should have a netid for comparing
            identity.netId = 42;

            // null should return false
            bool result = comp.SyncVarNetworkIdentityEqualExposed(null, identity.netId);
            Assert.That(result, Is.False);
        }

        // NOTE: SyncVarNetworkIdentityEqual should be static later
        [Test]
        public void SyncVarNetworkIdentityEqualValidIdentityWithDifferentNetId()
        {
            CreateNetworked(out GameObject _, out NetworkIdentity identity);

            // our identity should have a netid for comparing
            identity.netId = 42;

            // gameobject with valid networkidentity and netid that is different
            CreateNetworked(out GameObject go, out NetworkIdentity ni, out SyncVarNetworkIdentityEqualExposedBehaviour comp);
            ni.netId = 43;
            bool result = comp.SyncVarNetworkIdentityEqualExposed(ni, identity.netId);
            Assert.That(result, Is.False);
        }

        // NOTE: SyncVarNetworkIdentityEqual should be static later
        [Test]
        public void SyncVarNetworkIdentityEqualValidIdentityWithSameNetId()
        {
            CreateNetworked(out GameObject _, out NetworkIdentity identity);

            // our identity should have a netid for comparing
            identity.netId = 42;

            // gameobject with valid networkidentity and netid that is different
            CreateNetworked(out GameObject _, out NetworkIdentity ni, out SyncVarNetworkIdentityEqualExposedBehaviour comp);
            ni.netId = 42;
            bool result = comp.SyncVarNetworkIdentityEqualExposed(ni, identity.netId);
            Assert.That(result, Is.True);
        }

        // NOTE: SyncVarNetworkIdentityEqual should be static later
        [Test]
        public void SyncVarNetworkIdentityEqualUnspawnedIdentity()
        {
            CreateNetworked(out GameObject _, out NetworkIdentity identity);

            // our identity should have a netid for comparing
            identity.netId = 42;

            // gameobject with valid networkidentity and 0 netid that is unspawned
            CreateNetworked(out GameObject go, out NetworkIdentity ni, out SyncVarNetworkIdentityEqualExposedBehaviour comp);
            LogAssert.Expect(LogType.Warning, "SetSyncVarNetworkIdentity NetworkIdentity " + ni + " has a zero netId. Maybe it is not spawned yet?");
            bool result = comp.SyncVarNetworkIdentityEqualExposed(ni, identity.netId);
            Assert.That(result, Is.False);
        }

        // NOTE: SyncVarNetworkIdentityEqual should be static later
        [Test]
        public void SyncVarNetworkIdentityEqualUnspawnedIdentityZeroNetIdIsTrue()
        {
            CreateNetworked(out GameObject _, out NetworkIdentity identity);

            // unspawned go and identity.netid==0 returns true (=equal)
            CreateNetworked(out GameObject go, out NetworkIdentity ni, out SyncVarNetworkIdentityEqualExposedBehaviour comp);
            LogAssert.Expect(LogType.Warning, "SetSyncVarNetworkIdentity NetworkIdentity " + ni + " has a zero netId. Maybe it is not spawned yet?");
            bool result = comp.SyncVarNetworkIdentityEqualExposed(ni, identity.netId);
            Assert.That(result, Is.True);
        }

        [Test]
        public void SetSyncVarGameObjectWithValidObject()
        {
            CreateNetworked(out GameObject _, out NetworkIdentity _, out NetworkBehaviourSetSyncVarGameObjectComponent comp);

            // create a valid GameObject with networkidentity and netid
            CreateNetworked(out GameObject go, out NetworkIdentity ni);
            ni.netId = 43;

            // set the GameObject SyncVar
            Assert.That(comp.IsDirty(), Is.False);
            comp.SetSyncVarGameObjectExposed(go, 1ul);
            Assert.That(comp.test, Is.EqualTo(go));
            Assert.That(comp.testNetId, Is.EqualTo(ni.netId));
            Assert.That(comp.IsDirty(), Is.True);
        }

        [Test]
        public void SetSyncVarGameObjectNull()
        {
            CreateNetworked(out GameObject _, out NetworkIdentity _, out NetworkBehaviourSetSyncVarGameObjectComponent comp);

            // set some existing GO+netId first to check if it is going to be
            // overwritten
            CreateGameObject(out GameObject go);
            comp.test = go;
            comp.testNetId = 43;

            // set the GameObject SyncVar to null
            Assert.That(comp.IsDirty(), Is.False);
            comp.SetSyncVarGameObjectExposed(null, 1ul);
            Assert.That(comp.test, Is.EqualTo(null));
            Assert.That(comp.testNetId, Is.EqualTo(0));
            Assert.That(comp.IsDirty(), Is.True);
        }

        [Test]
        public void SetSyncVarGameObjectWithoutNetworkIdentity()
        {
            CreateNetworked(out GameObject _, out NetworkIdentity _, out NetworkBehaviourSetSyncVarGameObjectComponent comp);

            // set some existing GO+netId first to check if it is going to be
            // overwritten
            CreateGameObject(out GameObject go);
            comp.test = go;
            comp.testNetId = 43;

            // create test GO with no networkidentity
            CreateGameObject(out GameObject test);

            // set the GameObject SyncVar to 'test' GO without netidentity.
            // -> the way it currently works is that it sets netId to 0, but
            //    it DOES set gameObjectField to the GameObject without the
            //    NetworkIdentity, instead of setting it to null because it's
            //    seemingly invalid.
            // -> there might be a deeper reason why UNET did that. perhaps for
            //    cases where we assign a GameObject before the network was
            //    fully started and has no netId or networkidentity yet etc.
            // => it works, so let's keep it for now
            Assert.That(comp.IsDirty(), Is.False);
            comp.SetSyncVarGameObjectExposed(test, 1ul);
            Assert.That(comp.test, Is.EqualTo(test));
            Assert.That(comp.testNetId, Is.EqualTo(0));
            Assert.That(comp.IsDirty(), Is.True);
        }

        [Test]
        public void SetSyncVarGameObjectZeroNetId()
        {
            CreateNetworked(out GameObject gameObject, out NetworkIdentity identity, out NetworkBehaviourSetSyncVarGameObjectComponent comp);

            // set some existing GO+netId first to check if it is going to be
            // overwritten
            CreateGameObject(out GameObject go);
            comp.test = go;
            comp.testNetId = 43;

            // create test GO with networkidentity and zero netid
            CreateNetworked(out GameObject test, out NetworkIdentity ni);
            Assert.That(ni.netId, Is.EqualTo(0));

            // set the GameObject SyncVar to 'test' GO with zero netId.
            // -> the way it currently works is that it sets netId to 0, but
            //    it DOES set gameObjectField to the GameObject without the
            //    NetworkIdentity, instead of setting it to null because it's
            //    seemingly invalid.
            // -> there might be a deeper reason why UNET did that. perhaps for
            //    cases where we assign a GameObject before the network was
            //    fully started and has no netId or networkidentity yet etc.
            // => it works, so let's keep it for now
            Assert.That(comp.IsDirty(), Is.False);
            LogAssert.Expect(LogType.Warning, "SetSyncVarGameObject GameObject " + test + " has a zero netId. Maybe it is not spawned yet?");
            comp.SetSyncVarGameObjectExposed(test, 1ul);
            Assert.That(comp.test, Is.EqualTo(test));
            Assert.That(comp.testNetId, Is.EqualTo(0));
            Assert.That(comp.IsDirty(), Is.True);
        }

        [Test]
        public void GetSyncVarGameObjectOnServer()
        {
            CreateNetworked(out GameObject gameObject, out NetworkIdentity identity, out NetworkBehaviourGetSyncVarGameObjectComponent comp);

            // call OnStartServer so isServer is true
            identity.OnStartServer();
            Assert.That(identity.isServer, Is.True);

            // create a syncable GameObject
            CreateNetworked(out GameObject go, out NetworkIdentity ni);
            ni.netId = identity.netId + 1;

            // assign it in the component
            comp.test = go;
            comp.testNetId = ni.netId;

            // get it on the server. should simply return the field instead of
            // doing any netId lookup like on the client
            GameObject result = comp.GetSyncVarGameObjectExposed();
            Assert.That(result, Is.EqualTo(go));

            // clean up: set isServer false first, otherwise Destroy instead of DestroyImmediate is called
            identity.netId = 0;
        }

        [Test]
        public void GetSyncVarGameObjectOnServerNull()
        {
            CreateNetworked(out GameObject gameObject, out NetworkIdentity identity, out NetworkBehaviourGetSyncVarGameObjectComponent comp);

            // call OnStartServer and assign netId so isServer is true
            identity.OnStartServer();
            Assert.That(identity.isServer, Is.True);

            // get it on the server. null should work fine.
            GameObject result = comp.GetSyncVarGameObjectExposed();
            Assert.That(result, Is.Null);
        }

        [Test]
        public void GetSyncVarGameObjectOnClient()
        {
            CreateNetworked(out GameObject _, out NetworkIdentity identity);

            // are we on client and not on server?
            identity.isClient = true;
            Assert.That(identity.isServer, Is.False);

            // create a networked object with test component
            CreateNetworked(out GameObject _, out NetworkIdentity _, out NetworkBehaviourGetSyncVarGameObjectComponent comp);

            // create a syncable GameObject
            CreateNetworked(out GameObject go, out NetworkIdentity ni);
            ni.netId = 43;

            // register in spawned dict because clients should look it up via
            // netId
            NetworkIdentity.spawned[ni.netId] = ni;

            // assign ONLY netId in the component. assume that GameObject was
            // assigned earlier but client walked so far out of range that it
            // was despawned on the client. so it's forced to do the netId look-
            // up.
            Assert.That(comp.test, Is.Null);
            comp.testNetId = ni.netId;

            // get it on the client. should look up netId in spawned
            GameObject result = comp.GetSyncVarGameObjectExposed();
            Assert.That(result, Is.EqualTo(go));
        }

        [Test]
        public void GetSyncVarGameObjectOnClientNull()
        {
            CreateNetworked(out GameObject _, out NetworkIdentity identity);

            // are we on client and not on server?
            identity.isClient = true;
            Assert.That(identity.isServer, Is.False);

            // create a networked object with test component
            CreateNetworked(out GameObject _, out NetworkIdentity _, out NetworkBehaviourGetSyncVarGameObjectComponent comp);

            // get it on the client. null should be supported.
            GameObject result = comp.GetSyncVarGameObjectExposed();
            Assert.That(result, Is.Null);
        }

        [Test]
        public void SetSyncVarNetworkIdentityWithValidObject()
        {
            // create a networked object with test component
            CreateNetworked(out GameObject _, out NetworkIdentity _, out NetworkBehaviourSetSyncVarNetworkIdentityComponent comp);

            // create a valid GameObject with networkidentity and netid
            CreateNetworked(out GameObject _, out NetworkIdentity ni);
            ni.netId = 43;

            // set the NetworkIdentity SyncVar
            Assert.That(comp.IsDirty(), Is.False);
            comp.SetSyncVarNetworkIdentityExposed(ni, 1ul);
            Assert.That(comp.test, Is.EqualTo(ni));
            Assert.That(comp.testNetId, Is.EqualTo(ni.netId));
            Assert.That(comp.IsDirty(), Is.True);
        }

        [Test]
        public void SetSyncVarNetworkIdentityNull()
        {
            // create a networked object with test component
            CreateNetworked(out GameObject _, out NetworkIdentity _, out NetworkBehaviourSetSyncVarNetworkIdentityComponent comp);

            // set some existing NI+netId first to check if it is going to be
            // overwritten
            CreateNetworked(out GameObject _, out NetworkIdentity ni);
            comp.test = ni;
            comp.testNetId = 43;

            // set the NetworkIdentity SyncVar to null
            Assert.That(comp.IsDirty(), Is.False);
            comp.SetSyncVarNetworkIdentityExposed(null, 1ul);
            Assert.That(comp.test, Is.EqualTo(null));
            Assert.That(comp.testNetId, Is.EqualTo(0));
            Assert.That(comp.IsDirty(), Is.True);
        }

        [Test]
        public void SetSyncVarNetworkIdentityZeroNetId()
        {
            CreateNetworked(out GameObject gameObject, out NetworkIdentity identity, out NetworkBehaviourSetSyncVarNetworkIdentityComponent comp);

            // set some existing NI+netId first to check if it is going to be
            // overwritten
            CreateNetworked(out GameObject _, out NetworkIdentity ni);
            comp.test = ni;
            comp.testNetId = 43;

            // create test GO with networkidentity and zero netid
            CreateNetworked(out GameObject _, out NetworkIdentity testNi);
            Assert.That(testNi.netId, Is.EqualTo(0));

            // set the NetworkIdentity SyncVar to 'test' GO with zero netId.
            // -> the way it currently works is that it sets netId to 0, but
            //    it DOES set gameObjectField to the GameObject without the
            //    NetworkIdentity, instead of setting it to null because it's
            //    seemingly invalid.
            // -> there might be a deeper reason why UNET did that. perhaps for
            //    cases where we assign a GameObject before the network was
            //    fully started and has no netId or networkidentity yet etc.
            // => it works, so let's keep it for now
            Assert.That(comp.IsDirty(), Is.False);
            LogAssert.Expect(LogType.Warning, "SetSyncVarNetworkIdentity NetworkIdentity " + testNi + " has a zero netId. Maybe it is not spawned yet?");
            comp.SetSyncVarNetworkIdentityExposed(testNi, 1ul);
            Assert.That(comp.test, Is.EqualTo(testNi));
            Assert.That(comp.testNetId, Is.EqualTo(0));
            Assert.That(comp.IsDirty(), Is.True);
        }

        [Test]
        public void GetSyncVarNetworkIdentityOnServer()
        {
            CreateNetworked(out GameObject _, out NetworkIdentity identity, out NetworkBehaviourGetSyncVarNetworkIdentityComponent comp);

            // call OnStartServer so isServer is true
            identity.OnStartServer();
            Assert.That(identity.isServer, Is.True);

            // create a syncable GameObject
            CreateNetworked(out GameObject go, out NetworkIdentity ni);
            ni.netId = identity.netId + 1;

            // assign it in the component
            comp.test = ni;
            comp.testNetId = ni.netId;

            // get it on the server. should simply return the field instead of
            // doing any netId lookup like on the client
            NetworkIdentity result = comp.GetSyncVarNetworkIdentityExposed();
            Assert.That(result, Is.EqualTo(ni));
        }

        [Test]
        public void GetSyncVarNetworkIdentityOnServerNull()
        {
            CreateNetworked(out GameObject _, out NetworkIdentity identity, out NetworkBehaviourGetSyncVarNetworkIdentityComponent comp);

            // call OnStartServer so isServer is true
            identity.OnStartServer();
            Assert.That(identity.isServer, Is.True);

            // get it on the server. null should work fine.
            NetworkIdentity result = comp.GetSyncVarNetworkIdentityExposed();
            Assert.That(result, Is.Null);
        }

        [Test]
        public void GetSyncVarNetworkIdentityOnClient()
        {
            CreateNetworked(out GameObject _, out NetworkIdentity identity, out NetworkBehaviourGetSyncVarNetworkIdentityComponent comp);

            // are we on client and not on server?
            identity.isClient = true;
            Assert.That(identity.isServer, Is.False);

            // create a syncable GameObject
            CreateNetworked(out GameObject _, out NetworkIdentity ni);
            ni.netId = 43;

            // register in spawned dict because clients should look it up via
            // netId
            NetworkIdentity.spawned[ni.netId] = ni;

            // assign ONLY netId in the component. assume that GameObject was
            // assigned earlier but client walked so far out of range that it
            // was despawned on the client. so it's forced to do the netId look-
            // up.
            Assert.That(comp.test, Is.Null);
            comp.testNetId = ni.netId;

            // get it on the client. should look up netId in spawned
            NetworkIdentity result = comp.GetSyncVarNetworkIdentityExposed();
            Assert.That(result, Is.EqualTo(ni));
        }

        [Test]
        public void GetSyncVarNetworkIdentityOnClientNull()
        {
            CreateNetworked(out GameObject _, out NetworkIdentity identity, out NetworkBehaviourGetSyncVarNetworkIdentityComponent comp);

            // are we on client and not on server?
            identity.isClient = true;
            Assert.That(identity.isServer, Is.False);

            // get it on the client. null should be supported.
            NetworkIdentity result = comp.GetSyncVarNetworkIdentityExposed();
            Assert.That(result, Is.Null);
        }

        [Test]
        public void ClearAllDirtyBitsClearsSyncVarDirtyBits()
        {
            CreateNetworked(out GameObject _, out NetworkIdentity _, out EmptyBehaviour emptyBehaviour);

            // set syncinterval so dirtybit works fine
            emptyBehaviour.syncInterval = 0;
            Assert.That(emptyBehaviour.IsDirty(), Is.False);

            // set one syncvar dirty bit
            emptyBehaviour.SetDirtyBit(1);
            Assert.That(emptyBehaviour.IsDirty(), Is.True);

            // clear it
            emptyBehaviour.ClearAllDirtyBits();
            Assert.That(emptyBehaviour.IsDirty(), Is.False);
        }

        [Test]
        public void ClearAllDirtyBitsClearsSyncObjectsDirtyBits()
        {
            CreateNetworked(out GameObject _, out NetworkIdentity _, out NetworkBehaviourInitSyncObjectExposed comp);

            // set syncinterval so dirtybit works fine
            comp.syncInterval = 0;
            Assert.That(comp.IsDirty(), Is.False);

            // create a synclist and dirty it
            SyncList<int> obj = new SyncList<int>();
            obj.Add(42);
            Assert.That(obj.IsDirty, Is.True);

            // add it
            comp.InitSyncObjectExposed(obj);
            Assert.That(comp.IsDirty, Is.True);

            // clear bits should clear synclist bits too
            comp.ClearAllDirtyBits();
            Assert.That(comp.IsDirty, Is.False);
            Assert.That(obj.IsDirty, Is.False);
        }

        [Test]
        public void DirtyObjectBits()
        {
            CreateNetworked(out GameObject _, out NetworkIdentity _, out NetworkBehaviourInitSyncObjectExposed comp);

            // not dirty by default
            Assert.That(comp.DirtyObjectBits(), Is.EqualTo(0b0));

            // add a dirty synclist
            SyncList<int> dirtyList = new SyncList<int>();
            dirtyList.Add(42);
            Assert.That(dirtyList.IsDirty, Is.True);
            comp.InitSyncObjectExposed(dirtyList);

            // add a clean synclist
            SyncList<int> cleanList = new SyncList<int>();
            Assert.That(cleanList.IsDirty, Is.False);
            comp.InitSyncObjectExposed(cleanList);

            // get bits - only first one should be dirty
            Assert.That(comp.DirtyObjectBits(), Is.EqualTo(0b1));

            // set second one dirty. now we should have two dirty bits
            cleanList.Add(43);
            Assert.That(comp.DirtyObjectBits(), Is.EqualTo(0b11));
        }

        [Test]
        public void SerializeAndDeserializeObjectsAll()
        {
            CreateNetworked(out GameObject _, out NetworkIdentity _, out NetworkBehaviourInitSyncObjectExposed comp);

            // add a synclist
            SyncList<int> list = new SyncList<int>();
            list.Add(42);
            list.Add(43);
            Assert.That(list.IsDirty, Is.True);
            comp.InitSyncObjectExposed(list);

            // serialize it
            NetworkWriter writer = new NetworkWriter();
            comp.SerializeObjectsAll(writer);

            // clear original list
            list.Clear();
            Assert.That(list.Count, Is.EqualTo(0));

            // deserialize it
            NetworkReader reader = new NetworkReader(writer.ToArray());
            comp.DeSerializeObjectsAll(reader);
            Assert.That(list.Count, Is.EqualTo(2));
            Assert.That(list[0], Is.EqualTo(42));
            Assert.That(list[1], Is.EqualTo(43));
        }

        [Test]
        public void SerializeAndDeserializeObjectsDelta()
        {
            CreateNetworked(out GameObject _, out NetworkIdentity _, out NetworkBehaviourInitSyncObjectExposed comp);

            // add a synclist
            SyncList<int> list = new SyncList<int>();
            list.Add(42);
            list.Add(43);
            Assert.That(list.IsDirty, Is.True);
            comp.InitSyncObjectExposed(list);

            // serialize it
            NetworkWriter writer = new NetworkWriter();
            comp.SerializeObjectsDelta(writer);

            // clear original list
            list.Clear();
            Assert.That(list.Count, Is.EqualTo(0));

            // deserialize it
            NetworkReader reader = new NetworkReader(writer.ToArray());
            comp.DeSerializeObjectsDelta(reader);
            Assert.That(list.Count, Is.EqualTo(2));
            Assert.That(list[0], Is.EqualTo(42));
            Assert.That(list[1], Is.EqualTo(43));
        }

        [Test]
        public void OnStopClient()
        {
            CreateNetworked(out GameObject _, out NetworkIdentity identity, out OnStopClientComponent comp);
            identity.OnStopClient();
            Assert.That(comp.called, Is.EqualTo(1));
        }

        [Test]
        public void OnStartClient()
        {
            CreateNetworked(out GameObject _, out NetworkIdentity identity, out OnStartClientComponent comp);
            identity.OnStartClient();
            Assert.That(comp.called, Is.EqualTo(1));
        }

        [Test]
        public void OnStartLocalPlayer()
        {
            CreateNetworked(out GameObject _, out NetworkIdentity identity, out OnStartLocalPlayerComponent comp);
            identity.OnStartLocalPlayer();
            Assert.That(comp.called, Is.EqualTo(1));
        }
    }

    // we need to inherit from networkbehaviour to test protected functions
    public class NetworkBehaviourHookGuardTester : NetworkBehaviour
    {
        [Test]
        public void HookGuard()
        {
            // set hook guard for some bits
            for (int i = 0; i < 10; ++i)
            {
                ulong bit = 1ul << i;

                // should be false by default
                Assert.That(getSyncVarHookGuard(bit), Is.False);

                // set true
                setSyncVarHookGuard(bit, true);
                Assert.That(getSyncVarHookGuard(bit), Is.True);

                // set false again
                setSyncVarHookGuard(bit, false);
                Assert.That(getSyncVarHookGuard(bit), Is.False);
            }
        }
    }

    // we need to inherit from networkbehaviour to test protected functions
    public class NetworkBehaviourInitSyncObjectTester : NetworkBehaviour
    {
        [Test]
        public void InitSyncObject()
        {
            SyncObject syncObject = new SyncList<bool>();
            InitSyncObject(syncObject);
            Assert.That(syncObjects.Count, Is.EqualTo(1));
            Assert.That(syncObjects[0], Is.EqualTo(syncObject));
        }
    }
}
